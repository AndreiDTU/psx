#version 450
#extension GL_EXT_shader_16bit_storage : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require

layout(std140, binding = 1) uniform DrawArea {
    ivec2 drawing_area_top_left;
    ivec2 drawing_area_bottom_right;
};

struct Vertex {
    i16vec2 coords;
    uint color; // Packed 15-bit RGB (PS1 format)
    uint16_t texpage;
    uint16_t clut;
};

struct Tri {
    Vertex v0;
    Vertex v1;
    Vertex v2;
};

layout(std430, binding = 0) buffer TriangleBuffer {
    Tri tris[];
};

struct TriTask {
    ivec2 min;
    ivec2 max;
    ivec2 v0;
    ivec2 v1;
    ivec2 v2;
    uvec3 c0;
    uvec3 c1;
    uvec3 c2;
};

layout(std430, binding = 3) buffer TaskBuffer {
    TriTask tasks[];
};

layout(std430, binding = 4) buffer CounterBuffer {
    uint taskCount;
};

uvec3 unpack_ps1_color(uint col) {
    return uvec3(col & 0x1F, (col >> 5) & 0x1F, (col >> 10) & 0x1F) * 8;
}

void ensure_vertex_order(inout Vertex a, inout Vertex b, Vertex c) {
    int ax = int(a.coords.x), ay = int(a.coords.y);
    int bx = int(b.coords.x), by = int(b.coords.y);
    int cx = int(c.coords.x), cy = int(c.coords.y);

    int cross_product_z = (bx - ax) * (cy + ay) - (by - ay) * (cx - ax);

    if (cross_product_z < 0) {
        Vertex tmp = a;
        a = b;
        b = tmp;
    }
}

layout(local_size_x = 64) in;
void main() {
    uint idx = gl_GlobalInvocationID.x;
    Tri t = tris[idx];

    ensure_vertex_order(t.v0, t.v1, t.v2);

    ivec2 v0 = ivec2(t.v0.coords);
    ivec2 v1 = ivec2(t.v1.coords);
    ivec2 v2 = ivec2(t.v2.coords);

    int min_x = min(min(v0.x, v1.x), v2.x);
    int max_x = max(max(v0.x, v1.x), v2.x);
    int min_y = min(min(v0.y, v1.y), v2.y);
    int max_y = max(max(v0.y, v1.y), v2.y);

    min_x = max(min_x, drawing_area_top_left.x);
    max_x = min(max_x, drawing_area_bottom_right.x);
    min_y = max(min_y, drawing_area_top_left.y);
    max_y = min(max_y, drawing_area_bottom_right.y);

    if (min_x > max_x || min_y > max_y) {
        return;
    }

    uint task_index = atomicAdd(taskCount, 1);
    tasks[task_index].min = ivec2(min_x, min_y);
    tasks[task_index].max = ivec2(max_x, max_y);
    tasks[task_index].v0 = v0;
    tasks[task_index].v1 = v1;
    tasks[task_index].v2 = v2;
    tasks[task_index].c0 = unpack_ps1_color(t.v0.color);
    tasks[task_index].c1 = unpack_ps1_color(t.v1.color);
    tasks[task_index].c2 = unpack_ps1_color(t.v2.color);
}